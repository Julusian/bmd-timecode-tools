/* -LICENSE-START-
** Copyright (c) 2014 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "platform.h"
#include <iostream>
#include <atlcomcli.h>
#include <vector>

const INT8_UNSIGNED timecodeSyncFrameOffset = 4;

// Video mode parameters
const BMDDisplayMode      kDisplayMode = bmdModeHD1080i50;
const BMDPixelFormat      kPixelFormat = bmdFormat10BitYUV;

// The display mode object corresponding to kDisplayMode
IDeckLinkDisplayMode* gDisplayMode = NULL;

// Keep track of the number of scheduled frames
INT32_UNSIGNED gTotalFramesScheduled = 0;

template <typename T>
using com_ptr = CComPtr<T>;

template <typename T>
using com_iface_ptr = CComQIPtr<T>;

template <template <typename> class P, typename T>
static P<T> wrap_raw(T* ptr, bool already_referenced = false)
{
    if (already_referenced) {
        P<T> p;
        p.Attach(ptr);
        return p;
    }
    else
        return P<T>(ptr);
}

static com_ptr<IDeckLinkIterator> create_iterator()
{
    CComPtr<IDeckLinkIterator> pDecklinkIterator;
    if (FAILED(pDecklinkIterator.CoCreateInstance(CLSID_CDeckLinkIterator)))
        return nullptr;

    return pDecklinkIterator;
}

static com_ptr<IDeckLink> get_device(size_t device_index)
{
    auto pDecklinkIterator = create_iterator();

    size_t             n = 0;
    com_ptr<IDeckLink> decklink;
    IDeckLink* current = nullptr;

    // Obtain the first DeckLink device
    for (int i = 0; i <= device_index; i++) {
        auto result = pDecklinkIterator->Next(&current);
        if (result != S_OK)
            return nullptr;

        if (i == device_index)
            decklink = wrap_raw<com_ptr>(current);
        current = nullptr;
    }

    return decklink;
}

template <typename I, typename T>
static com_iface_ptr<I> iface_cast(const com_ptr<T>& ptr, bool optional = false)
{
    com_iface_ptr<I> result = ptr;

    if (!optional && !result)
        return nullptr;

    return result;
}

class InputCallback : public IDeckLinkInputCallback
{
    int index_;
    int runMode_;
public:


    InputCallback(int index, int runMode)
        : index_(index)
        , runMode_(runMode)
    {
    }

    // IUnknown needs only a dummy implementation
    virtual HRESULT	STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID* ppv)
    {
        return E_NOINTERFACE;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef()
    {
        return 1;
    }

    virtual ULONG STDMETHODCALLTYPE Release()
    {
        return 1;
    }


    virtual HRESULT STDMETHODCALLTYPE VideoInputFormatChanged(BMDVideoInputFormatChangedEvents /*notificationEvents*/,
        IDeckLinkDisplayMode* newDisplayMode,
        BMDDetectedVideoInputFormatFlags /*detectedSignalFlags*/)
    {
        // TODO
        return S_OK;
    }


    int countLinesInData(IDeckLinkVideoInputFrame* video) {
        uint8_t* bytes;
        if (S_OK == video->GetBytes((void**)&bytes)) {
            auto width = video->GetWidth();
            auto height = video->GetHeight();
            auto rowBytes = video->GetRowBytes();

            int newLineCount = 0;

            for (size_t i = 0; i < height; i++)
            {
                size_t offset = (rowBytes * i) + 1;
                uint8_t value = bytes[offset];

                if (value > 100) {
                    newLineCount++;
                }
                else {
                    break;
                }
            }

            return newLineCount;
        }
        else {
            return 0;
        }
    }

    int lastLineCount = -1;
    int frameCount = 0;
    int totalFrameCount = 0;

    virtual HRESULT STDMETHODCALLTYPE VideoInputFrameArrived(IDeckLinkVideoInputFrame* video, IDeckLinkAudioInputPacket* audio)
    {
        if (runMode_ == 1) {
            totalFrameCount++;

            int newLineCount = countLinesInData(video);

            int height = video->GetHeight();
            int lineDelta = newLineCount - lastLineCount;
            if (lineDelta < -height / 2) lineDelta += height;

            if (lineDelta == 2) {
                // All good
            }
            else {
                printf("%3d jumped from %3d to %3d \n", totalFrameCount, lastLineCount, newLineCount);
            }

            lastLineCount = newLineCount;

            
        }
        else if (runMode_ == 2) {
            totalFrameCount++;
            int newLineCount = countLinesInData(video);

            int height = video->GetHeight();
            int lineDelta = newLineCount - lastLineCount;
            if (lineDelta < -height / 2) lineDelta += height;

            if (newLineCount == lastLineCount) {
                frameCount++;
            } else if (lineDelta == 1) {
                if (frameCount != 23 && frameCount != 24 && frameCount != 25) {
                    printf("%3d incremented after %3d\n", totalFrameCount, frameCount);
                }
                frameCount = 0;
            }
            else {
                printf("%3d jumped from %3d to %3d after %3d frames\n", totalFrameCount, lastLineCount, newLineCount, frameCount);
                    frameCount = 0;
            }

            lastLineCount = newLineCount;

        }
        else {
            return S_FALSE;
        }

              

        return S_OK;
    }
};

int main(int argc, const char* argv[])
{

    IDeckLinkIterator* deckLinkIterator = NULL;
    IDeckLink* deckLink = NULL;
    HRESULT                 result;

    std::shared_ptr<InputCallback> cb;
    com_ptr<IDeckLink>                 decklink_;
    IDeckLinkInput* input_ = NULL;


    int i = 0;

    Initialize();

    // Create an IDeckLinkIterator object to enumerate all DeckLink cards in the system
    result = GetDeckLinkIterator(&deckLinkIterator);
    if (result != S_OK)
    {
        fprintf(stderr, "A DeckLink iterator could not be created.  The DeckLink drivers may not be installed.\n");
        goto bail;
    }

    while ((result = deckLinkIterator->Next(&deckLink)) == S_OK)
    {
        BSTR name;
        deckLink->GetDisplayName(&name);
        fprintf(stdout, "#%d - %ls \n", i, name);
        i++;
    }

    int inputIndex;
    std::cout << "Specify input device\n";
    std::cin >> inputIndex;

    int runMode;
    std::cout << "Specify mode\n" 
        << "1) Fast fill\n" 
        << "2) Slow fill\n";
    std::cin >> runMode;


    // Create an IDeckLinkIterator object to enumerate all DeckLink cards in the system
    result = GetDeckLinkIterator(&deckLinkIterator);
    if (result != S_OK)
    {
        fprintf(stderr, "A DeckLink iterator could not be created.  The DeckLink drivers may not be installed.\n");
        goto bail;
    }


    // now do input
    decklink_ = get_device(inputIndex);
    cb = std::make_shared<InputCallback>(inputIndex, runMode);

    BSTR name2;
    decklink_->GetDisplayName(&name2);
    fprintf(stdout, "Input device %ls \n", name2);

    if (decklink_->QueryInterface(IID_IDeckLinkInput, (void**)&input_) != S_OK)
    {
        fprintf(stderr, "Could not obtain the IDeckLinkInput interface \n");
        goto bail;
    }

    if (S_OK != (input_->EnableVideoInput(kDisplayMode, kPixelFormat, 0))) {
        fprintf(stderr, " Could not enable video input..\n");
        goto bail;
    }

//    if (S_OK != (input_->EnableAudioInput(bmdAudioSampleRate48kHz, bmdAudioSampleType32bitInteger, 2))) {
//        fprintf(stderr, " Could not enable audio input..\n");
//        goto bail;
//    }

    if (S_OK != (input_->SetCallback(cb.get())) != S_OK) {
        fprintf(stderr, " Failed to set input callback.\n");
        goto bail;
    }

    if (S_OK != (input_->StartStreams())) {
        fprintf(stderr, " Failed to start input stream.\n");
        goto bail;
    }


    printf("Press <RETURN> to exit\n");
    std::cin >> inputIndex;

    printf("Exiting.\n");

    // Release resources
bail:

    // Release the Decklink object
    if (deckLink != NULL)
        deckLink->Release();

    // Release the DeckLink iterator
    if (deckLinkIterator != NULL)
        deckLinkIterator->Release();

    return (result == S_OK) ? 0 : 1;
}

